/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_AST
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_AST

#include <VlppParser.h>

namespace vl
{
	namespace workflow
	{
		enum class WfParserTokenIndex
		{
			EXP = 0,
			ADD = 1,
			SUB = 2,
			MUL = 3,
			DIV = 4,
			MOD = 5,
			UNION = 6,
			INTERSECTION = 7,
			LE = 8,
			GE = 9,
			LT = 10,
			GT = 11,
			EQ = 12,
			NE = 13,
			ASSIGN = 14,
			FAILED_THEN = 15,
			QUESTION_MARK = 16,
			SCOPE_DELIMITER = 17,
			COLON = 18,
			SEMICOLON = 19,
			COMMA = 20,
			DOT = 21,
			OPEN_ARRAY = 22,
			CLOSE_ARRAY = 23,
			OPEN_BRACE = 24,
			CLOSE_BRACE = 25,
			OPEN_BRACKET = 26,
			CLOSE_BRACKET = 27,
			AT = 28,
			TYPE_VOID = 29,
			TYPE_OBJECT = 30,
			TYPE_INTERFACE = 31,
			TYPE_INT = 32,
			TYPE_UINT = 33,
			TYPE_FLOAT = 34,
			TYPE_DOUBLE = 35,
			TYPE_STRING = 36,
			TYPE_CHAR = 37,
			TYPE_BOOL = 38,
			KEYWORD_CONST = 39,
			KEYWORD_SHL = 40,
			KEYWORD_SHR = 41,
			KEYWORD_XOR = 42,
			KEYWORD_AND = 43,
			KEYWORD_OR = 44,
			KEYWORD_NOT = 45,
			KEYWORD_NULL = 46,
			KEYWORD_THIS = 47,
			KEYWORD_TRUE = 48,
			KEYWORD_FALSE = 49,
			KEYWORD_LET = 50,
			KEYWORD_IN = 51,
			KEYWORD_RANGE = 52,
			KEYWORD_NEW = 53,
			KEYWORD_OF = 54,
			KEYWORD_AS = 55,
			KEYWORD_IS = 56,
			KEYWORD_CAST = 57,
			KEYWORD_FUNC = 58,
			KEYWORD_TYPEOF = 59,
			KEYWORD_TYPE = 60,
			KEYWORD_BIND = 61,
			KEYWORD_OBSERVE = 62,
			KEYWORD_ON = 63,
			KEYWORD_ATTACH = 64,
			KEYWORD_DETACH = 65,
			KEYWORD_GOTO = 66,
			KEYWORD_VAR = 67,
			KEYWORD_BREAK = 68,
			KEYWORD_CONTINUE = 69,
			KEYWORD_RETURN = 70,
			KEYWORD_DELETE = 71,
			KEYWORD_RAISE = 72,
			KEYWORD_IF = 73,
			KEYWORD_ELSE = 74,
			KEYWORD_SWITCH = 75,
			KEYWORD_CASE = 76,
			KEYWORD_DEFAULT = 77,
			KEYWORD_WHILE = 78,
			KEYWORD_FOR = 79,
			KEYWORD_REVERSED = 80,
			KEYWORD_TRY = 81,
			KEYWORD_CATCH = 82,
			KEYWORD_FINALLY = 83,
			KEYWORD_CLASS = 84,
			KEYWORD_ENUM = 85,
			KEYWORD_FLAGENUM = 86,
			KEYWORD_STRUCT = 87,
			KEYWORD_PROP = 88,
			KEYWORD_EVENT = 89,
			KEYWORD_STATIC = 90,
			KEYWORD_OVERRIDE = 91,
			KEYWORD_USING = 92,
			KEYWORD_NAMESPACE = 93,
			KEYWORD_MODULE = 94,
			KEYWORD_UNIT = 95,
			STATE_MACHINE = 96,
			STATE_INPUT = 97,
			STATE_SWITCH = 98,
			STATE_GOTO = 99,
			STATE_PUSH = 100,
			STATE_DECL = 101,
			COROUTINE_COROUTINE = 102,
			COROUTINE_PAUSE = 103,
			COROUTINE_INTERFACE = 104,
			COROUTINE_OPERATOR = 105,
			COROUTINE_SIGN = 106,
			NAME = 107,
			ORDERED_NAME = 108,
			FLOAT = 109,
			INTEGER = 110,
			STRING = 111,
			FORMATSTRING = 112,
			SPACE = 113,
			COMMENT = 114,
		};
		class WfClassMember;
		class WfType;
		class WfExpression;
		class WfStatement;
		class WfAttribute;
		class WfDeclaration;
		class WfPredefinedType;
		class WfTopQualifiedType;
		class WfReferenceType;
		class WfRawPointerType;
		class WfSharedPointerType;
		class WfNullableType;
		class WfEnumerableType;
		class WfMapType;
		class WfObservableListType;
		class WfFunctionType;
		class WfChildType;
		class WfNamespaceDeclaration;
		class WfFunctionArgument;
		class WfFunctionDeclaration;
		class WfVariableDeclaration;
		class WfEventDeclaration;
		class WfPropertyDeclaration;
		class WfBaseConstructorCall;
		class WfConstructorDeclaration;
		class WfDestructorDeclaration;
		class WfClassDeclaration;
		class WfEnumItemIntersection;
		class WfEnumItem;
		class WfEnumDeclaration;
		class WfStructMember;
		class WfStructDeclaration;
		class WfVirtualCfeDeclaration;
		class WfAutoPropertyDeclaration;
		class WfCastResultInterfaceDeclaration;
		class WfVirtualCseDeclaration;
		class WfStateInput;
		class WfStateDeclaration;
		class WfStateMachineDeclaration;
		class WfBreakStatement;
		class WfContinueStatement;
		class WfReturnStatement;
		class WfDeleteStatement;
		class WfRaiseExceptionStatement;
		class WfIfStatement;
		class WfWhileStatement;
		class WfTryStatement;
		class WfBlockStatement;
		class WfGotoStatement;
		class WfVariableStatement;
		class WfExpressionStatement;
		class WfVirtualCseStatement;
		class WfForEachStatement;
		class WfSwitchCase;
		class WfSwitchStatement;
		class WfCoProviderStatement;
		class WfCoroutineStatement;
		class WfCoPauseStatement;
		class WfCoOperatorStatement;
		class WfStateMachineStatement;
		class WfStateSwitchArgument;
		class WfStateSwitchCase;
		class WfStateSwitchStatement;
		class WfStateInvokeStatement;
		class WfThisExpression;
		class WfTopQualifiedExpression;
		class WfReferenceExpression;
		class WfOrderedNameExpression;
		class WfOrderedLambdaExpression;
		class WfMemberExpression;
		class WfChildExpression;
		class WfLiteralExpression;
		class WfFloatingExpression;
		class WfIntegerExpression;
		class WfStringExpression;
		class WfUnaryExpression;
		class WfBinaryExpression;
		class WfLetVariable;
		class WfLetExpression;
		class WfIfExpression;
		class WfRangeExpression;
		class WfSetTestingExpression;
		class WfConstructorArgument;
		class WfConstructorExpression;
		class WfInferExpression;
		class WfTypeCastingExpression;
		class WfTypeTestingExpression;
		class WfTypeOfTypeExpression;
		class WfTypeOfExpressionExpression;
		class WfAttachEventExpression;
		class WfDetachEventExpression;
		class WfObserveExpression;
		class WfCallExpression;
		class WfFunctionExpression;
		class WfNewClassExpression;
		class WfNewInterfaceExpression;
		class WfVirtualCfeExpression;
		class WfFormatExpression;
		class WfVirtualCseExpression;
		class WfBindExpression;
		class WfNewCoroutineExpression;
		class WfMixinCastExpression;
		class WfExpectedTypeCastExpression;
		class WfCoOperatorExpression;
		class WfModuleUsingFragment;
		class WfModuleUsingNameFragment;
		class WfModuleUsingWildCardFragment;
		class WfModuleUsingItem;
		class WfModuleUsingPath;
		class WfModule;

		enum class WfClassMemberKind
		{
			Static,
			Override,
			Normal,
		};

		class WfClassMember : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfClassMember>
		{
		public:
			WfClassMemberKind kind;

			static vl::Ptr<WfClassMember> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfType abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfType>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfPredefinedType* node)=0;
				virtual void Visit(WfTopQualifiedType* node)=0;
				virtual void Visit(WfReferenceType* node)=0;
				virtual void Visit(WfRawPointerType* node)=0;
				virtual void Visit(WfSharedPointerType* node)=0;
				virtual void Visit(WfNullableType* node)=0;
				virtual void Visit(WfEnumerableType* node)=0;
				virtual void Visit(WfMapType* node)=0;
				virtual void Visit(WfObservableListType* node)=0;
				virtual void Visit(WfFunctionType* node)=0;
				virtual void Visit(WfChildType* node)=0;
			};

			virtual void Accept(WfType::IVisitor* visitor)=0;

		};

		class WfExpression abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfThisExpression* node)=0;
				virtual void Visit(WfTopQualifiedExpression* node)=0;
				virtual void Visit(WfReferenceExpression* node)=0;
				virtual void Visit(WfOrderedNameExpression* node)=0;
				virtual void Visit(WfOrderedLambdaExpression* node)=0;
				virtual void Visit(WfMemberExpression* node)=0;
				virtual void Visit(WfChildExpression* node)=0;
				virtual void Visit(WfLiteralExpression* node)=0;
				virtual void Visit(WfFloatingExpression* node)=0;
				virtual void Visit(WfIntegerExpression* node)=0;
				virtual void Visit(WfStringExpression* node)=0;
				virtual void Visit(WfUnaryExpression* node)=0;
				virtual void Visit(WfBinaryExpression* node)=0;
				virtual void Visit(WfLetExpression* node)=0;
				virtual void Visit(WfIfExpression* node)=0;
				virtual void Visit(WfRangeExpression* node)=0;
				virtual void Visit(WfSetTestingExpression* node)=0;
				virtual void Visit(WfConstructorExpression* node)=0;
				virtual void Visit(WfInferExpression* node)=0;
				virtual void Visit(WfTypeCastingExpression* node)=0;
				virtual void Visit(WfTypeTestingExpression* node)=0;
				virtual void Visit(WfTypeOfTypeExpression* node)=0;
				virtual void Visit(WfTypeOfExpressionExpression* node)=0;
				virtual void Visit(WfAttachEventExpression* node)=0;
				virtual void Visit(WfDetachEventExpression* node)=0;
				virtual void Visit(WfObserveExpression* node)=0;
				virtual void Visit(WfCallExpression* node)=0;
				virtual void Visit(WfFunctionExpression* node)=0;
				virtual void Visit(WfNewClassExpression* node)=0;
				virtual void Visit(WfNewInterfaceExpression* node)=0;
				virtual void Visit(WfVirtualCfeExpression* node)=0;
				virtual void Visit(WfVirtualCseExpression* node)=0;
			};

			virtual void Accept(WfExpression::IVisitor* visitor)=0;

		};

		class WfStatement abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfBreakStatement* node)=0;
				virtual void Visit(WfContinueStatement* node)=0;
				virtual void Visit(WfReturnStatement* node)=0;
				virtual void Visit(WfDeleteStatement* node)=0;
				virtual void Visit(WfRaiseExceptionStatement* node)=0;
				virtual void Visit(WfIfStatement* node)=0;
				virtual void Visit(WfWhileStatement* node)=0;
				virtual void Visit(WfTryStatement* node)=0;
				virtual void Visit(WfBlockStatement* node)=0;
				virtual void Visit(WfGotoStatement* node)=0;
				virtual void Visit(WfVariableStatement* node)=0;
				virtual void Visit(WfExpressionStatement* node)=0;
				virtual void Visit(WfVirtualCseStatement* node)=0;
				virtual void Visit(WfCoroutineStatement* node)=0;
				virtual void Visit(WfStateMachineStatement* node)=0;
			};

			virtual void Accept(WfStatement::IVisitor* visitor)=0;

		};

		class WfAttribute : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfAttribute>
		{
		public:
			vl::parsing::ParsingToken category;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfAttribute> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeclaration abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfNamespaceDeclaration* node)=0;
				virtual void Visit(WfFunctionDeclaration* node)=0;
				virtual void Visit(WfVariableDeclaration* node)=0;
				virtual void Visit(WfEventDeclaration* node)=0;
				virtual void Visit(WfPropertyDeclaration* node)=0;
				virtual void Visit(WfConstructorDeclaration* node)=0;
				virtual void Visit(WfDestructorDeclaration* node)=0;
				virtual void Visit(WfClassDeclaration* node)=0;
				virtual void Visit(WfEnumDeclaration* node)=0;
				virtual void Visit(WfStructDeclaration* node)=0;
				virtual void Visit(WfVirtualCfeDeclaration* node)=0;
				virtual void Visit(WfVirtualCseDeclaration* node)=0;
			};

			virtual void Accept(WfDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfClassMember> classMember;
		};

		enum class WfPredefinedTypeName
		{
			Void,
			Object,
			Interface,
			Int,
			UInt,
			Float,
			Double,
			String,
			Char,
			Bool,
		};

		class WfPredefinedType : public WfType, vl::reflection::Description<WfPredefinedType>
		{
		public:
			WfPredefinedTypeName name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfPredefinedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTopQualifiedType : public WfType, vl::reflection::Description<WfTopQualifiedType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceType : public WfType, vl::reflection::Description<WfReferenceType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRawPointerType : public WfType, vl::reflection::Description<WfRawPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfRawPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSharedPointerType : public WfType, vl::reflection::Description<WfSharedPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfSharedPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNullableType : public WfType, vl::reflection::Description<WfNullableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfNullableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumerableType : public WfType, vl::reflection::Description<WfEnumerableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfEnumerableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfMapWritability
		{
			Readonly,
			Writable,
		};

		class WfMapType : public WfType, vl::reflection::Description<WfMapType>
		{
		public:
			WfMapWritability writability;
			vl::Ptr<WfType> key;
			vl::Ptr<WfType> value;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfMapType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfObservableListType : public WfType, vl::reflection::Description<WfObservableListType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfObservableListType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionType : public WfType, vl::reflection::Description<WfFunctionType>
		{
		public:
			vl::Ptr<WfType> result;
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildType : public WfType, vl::reflection::Description<WfChildType>
		{
		public:
			vl::Ptr<WfType> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfChildType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNamespaceDeclaration : public WfDeclaration, vl::reflection::Description<WfNamespaceDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfNamespaceDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfFunctionArgument>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfType> type;

			static vl::Ptr<WfFunctionArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfFunctionAnonymity
		{
			Named,
			Anonymous,
		};

		class WfFunctionDeclaration : public WfDeclaration, vl::reflection::Description<WfFunctionDeclaration>
		{
		public:
			WfFunctionAnonymity anonymity;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfType> returnType;
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableDeclaration : public WfDeclaration, vl::reflection::Description<WfVariableDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::Ptr<WfExpression> expression;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfVariableDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEventDeclaration : public WfDeclaration, vl::reflection::Description<WfEventDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfEventDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfPropertyDeclaration : public WfDeclaration, vl::reflection::Description<WfPropertyDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken getter;
			vl::parsing::ParsingToken setter;
			vl::parsing::ParsingToken valueChangedEvent;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfPropertyDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfClassKind
		{
			Class,
			Interface,
		};

		enum class WfConstructorType
		{
			Undefined,
			SharedPtr,
			RawPtr,
		};

		class WfBaseConstructorCall : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfBaseConstructorCall>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			static vl::Ptr<WfBaseConstructorCall> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorDeclaration : public WfDeclaration, vl::reflection::Description<WfConstructorDeclaration>
		{
		public:
			WfConstructorType constructorType;
			vl::collections::List<vl::Ptr<WfBaseConstructorCall>> baseConstructorCalls;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfConstructorDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDestructorDeclaration : public WfDeclaration, vl::reflection::Description<WfDestructorDeclaration>
		{
		public:
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfDestructorDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfClassDeclaration : public WfDeclaration, vl::reflection::Description<WfClassDeclaration>
		{
		public:
			WfClassKind kind;
			WfConstructorType constructorType;
			vl::collections::List<vl::Ptr<WfType>> baseTypes;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfClassDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfEnumKind
		{
			Normal,
			Flag,
		};

		enum class WfEnumItemKind
		{
			Constant,
			Intersection,
		};

		class WfEnumItemIntersection : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfEnumItemIntersection>
		{
		public:
			vl::parsing::ParsingToken name;

			static vl::Ptr<WfEnumItemIntersection> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumItem : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfEnumItem>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			WfEnumItemKind kind;
			vl::parsing::ParsingToken number;
			vl::collections::List<vl::Ptr<WfEnumItemIntersection>> intersections;

			static vl::Ptr<WfEnumItem> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumDeclaration : public WfDeclaration, vl::reflection::Description<WfEnumDeclaration>
		{
		public:
			WfEnumKind kind;
			vl::collections::List<vl::Ptr<WfEnumItem>> items;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfEnumDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStructMember : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStructMember>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfType> type;

			static vl::Ptr<WfStructMember> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStructDeclaration : public WfDeclaration, vl::reflection::Description<WfStructDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfStructMember>> members;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfStructDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCfeDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCfeDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfAutoPropertyDeclaration* node)=0;
				virtual void Visit(WfCastResultInterfaceDeclaration* node)=0;
			};

			virtual void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;
		};

		enum class WfAPConst
		{
			Readonly,
			Writable,
		};

		enum class WfAPObserve
		{
			Observable,
			NotObservable,
		};

		class WfAutoPropertyDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfAutoPropertyDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			WfAPConst configConst;
			WfAPObserve configObserve;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfAutoPropertyDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCastResultInterfaceDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfCastResultInterfaceDeclaration>
		{
		public:
			vl::Ptr<WfType> baseType;
			vl::Ptr<WfType> elementType;

			void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfCastResultInterfaceDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCseDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfStateMachineDeclaration* node)=0;
			};

			virtual void Accept(WfVirtualCseDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;
		};

		class WfStateInput : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateInput>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;

			static vl::Ptr<WfStateInput> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateDeclaration : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateDeclaration>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfStateDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateMachineDeclaration : public WfVirtualCseDeclaration, vl::reflection::Description<WfStateMachineDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfStateInput>> inputs;
			vl::collections::List<vl::Ptr<WfStateDeclaration>> states;

			void Accept(WfVirtualCseDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfStateMachineDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBreakStatement : public WfStatement, vl::reflection::Description<WfBreakStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBreakStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfContinueStatement : public WfStatement, vl::reflection::Description<WfContinueStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfContinueStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReturnStatement : public WfStatement, vl::reflection::Description<WfReturnStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfReturnStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeleteStatement : public WfStatement, vl::reflection::Description<WfDeleteStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfDeleteStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRaiseExceptionStatement : public WfStatement, vl::reflection::Description<WfRaiseExceptionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfRaiseExceptionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfStatement : public WfStatement, vl::reflection::Description<WfIfStatement>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> trueBranch;
			vl::Ptr<WfStatement> falseBranch;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfIfStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfWhileStatement : public WfStatement, vl::reflection::Description<WfWhileStatement>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfStatement> statement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfWhileStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTryStatement : public WfStatement, vl::reflection::Description<WfTryStatement>
		{
		public:
			vl::Ptr<WfStatement> protectedStatement;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> catchStatement;
			vl::Ptr<WfStatement> finallyStatement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfTryStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBlockStatement : public WfStatement, vl::reflection::Description<WfBlockStatement>
		{
		public:
			vl::collections::List<vl::Ptr<WfStatement>> statements;
			vl::parsing::ParsingToken endLabel;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBlockStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfGotoStatement : public WfStatement, vl::reflection::Description<WfGotoStatement>
		{
		public:
			vl::parsing::ParsingToken label;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfGotoStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableStatement : public WfStatement, vl::reflection::Description<WfVariableStatement>
		{
		public:
			vl::Ptr<WfVariableDeclaration> variable;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfVariableStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpressionStatement : public WfStatement, vl::reflection::Description<WfExpressionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfExpressionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseStatement abstract : public WfStatement, vl::reflection::Description<WfVirtualCseStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfForEachStatement* node)=0;
				virtual void Visit(WfSwitchStatement* node)=0;
				virtual void Visit(WfCoProviderStatement* node)=0;
			};

			virtual void Accept(WfVirtualCseStatement::IVisitor* visitor)=0;

			vl::Ptr<WfStatement> expandedStatement;

			void Accept(WfStatement::IVisitor* visitor)override;
		};

		enum class WfForEachDirection
		{
			Normal,
			Reversed,
		};

		class WfForEachStatement : public WfVirtualCseStatement, vl::reflection::Description<WfForEachStatement>
		{
		public:
			vl::parsing::ParsingToken name;
			WfForEachDirection direction;
			vl::Ptr<WfExpression> collection;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfForEachStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchCase : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfSwitchCase>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfSwitchCase> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchStatement : public WfVirtualCseStatement, vl::reflection::Description<WfSwitchStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfSwitchCase>> caseBranches;
			vl::Ptr<WfStatement> defaultBranch;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfSwitchStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoProviderStatement : public WfVirtualCseStatement, vl::reflection::Description<WfCoProviderStatement>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoProviderStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoroutineStatement abstract : public WfStatement, vl::reflection::Description<WfCoroutineStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfCoPauseStatement* node)=0;
				virtual void Visit(WfCoOperatorStatement* node)=0;
			};

			virtual void Accept(WfCoroutineStatement::IVisitor* visitor)=0;


			void Accept(WfStatement::IVisitor* visitor)override;
		};

		class WfCoPauseStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoPauseStatement>
		{
		public:
			vl::Ptr<WfStatement> statement;

			void Accept(WfCoroutineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoPauseStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoOperatorStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoOperatorStatement>
		{
		public:
			vl::parsing::ParsingToken varName;
			vl::parsing::ParsingToken opName;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfCoroutineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoOperatorStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfStateSwitchType
		{
			Default,
			Pass,
			PassAndReturn,
			Ignore,
			IgnoreAndReturn,
		};

		enum class WfStateInvokeType
		{
			Goto,
			Push,
		};

		class WfStateMachineStatement abstract : public WfStatement, vl::reflection::Description<WfStateMachineStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfStateSwitchStatement* node)=0;
				virtual void Visit(WfStateInvokeStatement* node)=0;
			};

			virtual void Accept(WfStateMachineStatement::IVisitor* visitor)=0;


			void Accept(WfStatement::IVisitor* visitor)override;
		};

		class WfStateSwitchArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateSwitchArgument>
		{
		public:
			vl::parsing::ParsingToken name;

			static vl::Ptr<WfStateSwitchArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateSwitchCase : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateSwitchCase>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfStateSwitchArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfStateSwitchCase> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateSwitchStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateSwitchStatement>
		{
		public:
			WfStateSwitchType type;
			vl::collections::List<vl::Ptr<WfStateSwitchCase>> caseBranches;

			void Accept(WfStateMachineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfStateSwitchStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateInvokeStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateInvokeStatement>
		{
		public:
			WfStateInvokeType type;
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfStateMachineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfStateInvokeStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfThisExpression : public WfExpression, vl::reflection::Description<WfThisExpression>
		{
		public:

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfThisExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTopQualifiedExpression : public WfExpression, vl::reflection::Description<WfTopQualifiedExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceExpression : public WfExpression, vl::reflection::Description<WfReferenceExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedNameExpression : public WfExpression, vl::reflection::Description<WfOrderedNameExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedNameExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedLambdaExpression : public WfExpression, vl::reflection::Description<WfOrderedLambdaExpression>
		{
		public:
			vl::Ptr<WfExpression> body;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedLambdaExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfMemberExpression : public WfExpression, vl::reflection::Description<WfMemberExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfMemberExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildExpression : public WfExpression, vl::reflection::Description<WfChildExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfChildExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfLiteralValue
		{
			Null,
			True,
			False,
		};

		class WfLiteralExpression : public WfExpression, vl::reflection::Description<WfLiteralExpression>
		{
		public:
			WfLiteralValue value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLiteralExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFloatingExpression : public WfExpression, vl::reflection::Description<WfFloatingExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFloatingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIntegerExpression : public WfExpression, vl::reflection::Description<WfIntegerExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIntegerExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStringExpression : public WfExpression, vl::reflection::Description<WfStringExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfStringExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfUnaryOperator
		{
			Positive,
			Negative,
			Not,
		};

		class WfUnaryExpression : public WfExpression, vl::reflection::Description<WfUnaryExpression>
		{
		public:
			WfUnaryOperator op;
			vl::Ptr<WfExpression> operand;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfUnaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfBinaryOperator
		{
			Assign,
			Index,
			Union,
			Intersect,
			FailedThen,
			Exp,
			Add,
			Sub,
			Mul,
			Div,
			Mod,
			Shl,
			Shr,
			LT,
			GT,
			LE,
			GE,
			EQ,
			NE,
			Xor,
			And,
			Or,
		};

		class WfBinaryExpression : public WfExpression, vl::reflection::Description<WfBinaryExpression>
		{
		public:
			WfBinaryOperator op;
			vl::Ptr<WfExpression> first;
			vl::Ptr<WfExpression> second;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBinaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetVariable : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfLetVariable>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfLetVariable> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetExpression : public WfExpression, vl::reflection::Description<WfLetExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfLetVariable>> variables;
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLetExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfExpression : public WfExpression, vl::reflection::Description<WfIfExpression>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfExpression> trueBranch;
			vl::Ptr<WfExpression> falseBranch;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIfExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfRangeBoundary
		{
			Inclusive,
			Exclusive,
		};

		class WfRangeExpression : public WfExpression, vl::reflection::Description<WfRangeExpression>
		{
		public:
			vl::Ptr<WfExpression> begin;
			WfRangeBoundary beginBoundary;
			vl::Ptr<WfExpression> end;
			WfRangeBoundary endBoundary;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfRangeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfSetTesting
		{
			In,
			NotIn,
		};

		class WfSetTestingExpression : public WfExpression, vl::reflection::Description<WfSetTestingExpression>
		{
		public:
			WfSetTesting test;
			vl::Ptr<WfExpression> element;
			vl::Ptr<WfExpression> collection;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfSetTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfConstructorArgument>
		{
		public:
			vl::Ptr<WfExpression> key;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfConstructorArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorExpression : public WfExpression, vl::reflection::Description<WfConstructorExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfConstructorArgument>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfConstructorExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfInferExpression : public WfExpression, vl::reflection::Description<WfInferExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfInferExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeCastingStrategy
		{
			Strong,
			Weak,
		};

		class WfTypeCastingExpression : public WfExpression, vl::reflection::Description<WfTypeCastingExpression>
		{
		public:
			WfTypeCastingStrategy strategy;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeCastingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeTesting
		{
			IsType,
			IsNotType,
			IsNull,
			IsNotNull,
		};

		class WfTypeTestingExpression : public WfExpression, vl::reflection::Description<WfTypeTestingExpression>
		{
		public:
			WfTypeTesting test;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfTypeExpression : public WfExpression, vl::reflection::Description<WfTypeOfTypeExpression>
		{
		public:
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfTypeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfExpressionExpression : public WfExpression, vl::reflection::Description<WfTypeOfExpressionExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfExpressionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfAttachEventExpression : public WfExpression, vl::reflection::Description<WfAttachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> event;
			vl::Ptr<WfExpression> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfAttachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDetachEventExpression : public WfExpression, vl::reflection::Description<WfDetachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> event;
			vl::Ptr<WfExpression> handler;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfDetachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfObserveType
		{
			SimpleObserve,
			ExtendedObserve,
		};

		class WfObserveExpression : public WfExpression, vl::reflection::Description<WfObserveExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			WfObserveType observeType;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfExpression>> events;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfObserveExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCallExpression : public WfExpression, vl::reflection::Description<WfCallExpression>
		{
		public:
			vl::Ptr<WfExpression> function;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfCallExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionExpression : public WfExpression, vl::reflection::Description<WfFunctionExpression>
		{
		public:
			vl::Ptr<WfFunctionDeclaration> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewClassExpression : public WfExpression, vl::reflection::Description<WfNewClassExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewClassExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewInterfaceExpression : public WfExpression, vl::reflection::Description<WfNewInterfaceExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewInterfaceExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCfeExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCfeExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfFormatExpression* node)=0;
			};

			virtual void Accept(WfVirtualCfeExpression::IVisitor* visitor)=0;

			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;
		};

		class WfFormatExpression : public WfVirtualCfeExpression, vl::reflection::Description<WfFormatExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfVirtualCfeExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFormatExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCseExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfBindExpression* node)=0;
				virtual void Visit(WfNewCoroutineExpression* node)=0;
				virtual void Visit(WfMixinCastExpression* node)=0;
				virtual void Visit(WfExpectedTypeCastExpression* node)=0;
				virtual void Visit(WfCoOperatorExpression* node)=0;
			};

			virtual void Accept(WfVirtualCseExpression::IVisitor* visitor)=0;

			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;
		};

		class WfBindExpression : public WfVirtualCseExpression, vl::reflection::Description<WfBindExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBindExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewCoroutineExpression : public WfVirtualCseExpression, vl::reflection::Description<WfNewCoroutineExpression>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewCoroutineExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfMixinCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfMixinCastExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfMixinCastExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpectedTypeCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfExpectedTypeCastExpression>
		{
		public:
			WfTypeCastingStrategy strategy;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfExpectedTypeCastExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoOperatorExpression : public WfVirtualCseExpression, vl::reflection::Description<WfCoOperatorExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfCoOperatorExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingFragment abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingFragment>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfModuleUsingNameFragment* node)=0;
				virtual void Visit(WfModuleUsingWildCardFragment* node)=0;
			};

			virtual void Accept(WfModuleUsingFragment::IVisitor* visitor)=0;

		};

		class WfModuleUsingNameFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingNameFragment>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingNameFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingWildCardFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingWildCardFragment>
		{
		public:

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingWildCardFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingItem : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingItem>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingFragment>> fragments;

			static vl::Ptr<WfModuleUsingItem> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingPath : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingPath>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingItem>> items;

			static vl::Ptr<WfModuleUsingPath> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfModuleType
		{
			Module,
			Unit,
		};

		class WfModule : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModule>
		{
		public:
			WfModuleType moduleType;
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfModuleUsingPath>> paths;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			static vl::Ptr<WfModule> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::workflow::WfClassMemberKind)
			DECL_TYPE_INFO(vl::workflow::WfClassMember)
			DECL_TYPE_INFO(vl::workflow::WfType)
			DECL_TYPE_INFO(vl::workflow::WfExpression)
			DECL_TYPE_INFO(vl::workflow::WfStatement)
			DECL_TYPE_INFO(vl::workflow::WfAttribute)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedType)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedType)
			DECL_TYPE_INFO(vl::workflow::WfReferenceType)
			DECL_TYPE_INFO(vl::workflow::WfRawPointerType)
			DECL_TYPE_INFO(vl::workflow::WfSharedPointerType)
			DECL_TYPE_INFO(vl::workflow::WfNullableType)
			DECL_TYPE_INFO(vl::workflow::WfEnumerableType)
			DECL_TYPE_INFO(vl::workflow::WfMapWritability)
			DECL_TYPE_INFO(vl::workflow::WfMapType)
			DECL_TYPE_INFO(vl::workflow::WfObservableListType)
			DECL_TYPE_INFO(vl::workflow::WfFunctionType)
			DECL_TYPE_INFO(vl::workflow::WfChildType)
			DECL_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfFunctionArgument)
			DECL_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
			DECL_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVariableDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfEventDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfClassKind)
			DECL_TYPE_INFO(vl::workflow::WfConstructorType)
			DECL_TYPE_INFO(vl::workflow::WfBaseConstructorCall)
			DECL_TYPE_INFO(vl::workflow::WfConstructorDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfDestructorDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfClassDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfEnumKind)
			DECL_TYPE_INFO(vl::workflow::WfEnumItemKind)
			DECL_TYPE_INFO(vl::workflow::WfEnumItemIntersection)
			DECL_TYPE_INFO(vl::workflow::WfEnumItem)
			DECL_TYPE_INFO(vl::workflow::WfEnumDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStructMember)
			DECL_TYPE_INFO(vl::workflow::WfStructDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfAPConst)
			DECL_TYPE_INFO(vl::workflow::WfAPObserve)
			DECL_TYPE_INFO(vl::workflow::WfAutoPropertyDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfCastResultInterfaceDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStateInput)
			DECL_TYPE_INFO(vl::workflow::WfStateDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfBreakStatement)
			DECL_TYPE_INFO(vl::workflow::WfContinueStatement)
			DECL_TYPE_INFO(vl::workflow::WfReturnStatement)
			DECL_TYPE_INFO(vl::workflow::WfDeleteStatement)
			DECL_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
			DECL_TYPE_INFO(vl::workflow::WfIfStatement)
			DECL_TYPE_INFO(vl::workflow::WfWhileStatement)
			DECL_TYPE_INFO(vl::workflow::WfTryStatement)
			DECL_TYPE_INFO(vl::workflow::WfBlockStatement)
			DECL_TYPE_INFO(vl::workflow::WfGotoStatement)
			DECL_TYPE_INFO(vl::workflow::WfVariableStatement)
			DECL_TYPE_INFO(vl::workflow::WfExpressionStatement)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement)
			DECL_TYPE_INFO(vl::workflow::WfForEachDirection)
			DECL_TYPE_INFO(vl::workflow::WfForEachStatement)
			DECL_TYPE_INFO(vl::workflow::WfSwitchCase)
			DECL_TYPE_INFO(vl::workflow::WfSwitchStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoProviderStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoPauseStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoOperatorStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchType)
			DECL_TYPE_INFO(vl::workflow::WfStateInvokeType)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchArgument)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchCase)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateInvokeStatement)
			DECL_TYPE_INFO(vl::workflow::WfThisExpression)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
			DECL_TYPE_INFO(vl::workflow::WfReferenceExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
			DECL_TYPE_INFO(vl::workflow::WfMemberExpression)
			DECL_TYPE_INFO(vl::workflow::WfChildExpression)
			DECL_TYPE_INFO(vl::workflow::WfLiteralValue)
			DECL_TYPE_INFO(vl::workflow::WfLiteralExpression)
			DECL_TYPE_INFO(vl::workflow::WfFloatingExpression)
			DECL_TYPE_INFO(vl::workflow::WfIntegerExpression)
			DECL_TYPE_INFO(vl::workflow::WfStringExpression)
			DECL_TYPE_INFO(vl::workflow::WfUnaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfUnaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfBinaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfBinaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfLetVariable)
			DECL_TYPE_INFO(vl::workflow::WfLetExpression)
			DECL_TYPE_INFO(vl::workflow::WfIfExpression)
			DECL_TYPE_INFO(vl::workflow::WfRangeBoundary)
			DECL_TYPE_INFO(vl::workflow::WfRangeExpression)
			DECL_TYPE_INFO(vl::workflow::WfSetTesting)
			DECL_TYPE_INFO(vl::workflow::WfSetTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfConstructorArgument)
			DECL_TYPE_INFO(vl::workflow::WfConstructorExpression)
			DECL_TYPE_INFO(vl::workflow::WfInferExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeTesting)
			DECL_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
			DECL_TYPE_INFO(vl::workflow::WfAttachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfDetachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfObserveType)
			DECL_TYPE_INFO(vl::workflow::WfObserveExpression)
			DECL_TYPE_INFO(vl::workflow::WfCallExpression)
			DECL_TYPE_INFO(vl::workflow::WfFunctionExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewClassExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewInterfaceExpression)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression)
			DECL_TYPE_INFO(vl::workflow::WfFormatExpression)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression)
			DECL_TYPE_INFO(vl::workflow::WfBindExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewCoroutineExpression)
			DECL_TYPE_INFO(vl::workflow::WfMixinCastExpression)
			DECL_TYPE_INFO(vl::workflow::WfExpectedTypeCastExpression)
			DECL_TYPE_INFO(vl::workflow::WfCoOperatorExpression)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingItem)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingPath)
			DECL_TYPE_INFO(vl::workflow::WfModuleType)
			DECL_TYPE_INFO(vl::workflow::WfModule)
			DECL_TYPE_INFO(vl::workflow::WfType::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfType::IVisitor)
				void Visit(vl::workflow::WfPredefinedType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTopQualifiedType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReferenceType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRawPointerType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSharedPointerType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNullableType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEnumerableType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMapType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfObservableListType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfChildType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfType::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfExpression::IVisitor)
				void Visit(vl::workflow::WfThisExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTopQualifiedExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReferenceExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfOrderedNameExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfOrderedLambdaExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMemberExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfChildExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfLiteralExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFloatingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIntegerExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStringExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfUnaryExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfBinaryExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfLetExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIfExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRangeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSetTestingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfConstructorExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfInferExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeCastingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeTestingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeOfTypeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeOfExpressionExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfAttachEventExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDetachEventExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfObserveExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCallExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewClassExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewInterfaceExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCfeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStatement::IVisitor)
				void Visit(vl::workflow::WfBreakStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfContinueStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReturnStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDeleteStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRaiseExceptionStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIfStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfWhileStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTryStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfBlockStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfGotoStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVariableStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfExpressionStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoroutineStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStateMachineStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfDeclaration::IVisitor)
				void Visit(vl::workflow::WfNamespaceDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVariableDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEventDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfPropertyDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfConstructorDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDestructorDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfClassDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEnumDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStructDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCfeDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
				void Visit(vl::workflow::WfAutoPropertyDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCastResultInterfaceDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseDeclaration::IVisitor)
				void Visit(vl::workflow::WfStateMachineDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseStatement::IVisitor)
				void Visit(vl::workflow::WfForEachStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSwitchStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoProviderStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfCoroutineStatement::IVisitor)
				void Visit(vl::workflow::WfCoPauseStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoOperatorStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfCoroutineStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStateMachineStatement::IVisitor)
				void Visit(vl::workflow::WfStateSwitchStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStateInvokeStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfStateMachineStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeExpression::IVisitor)
				void Visit(vl::workflow::WfFormatExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseExpression::IVisitor)
				void Visit(vl::workflow::WfBindExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewCoroutineExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMixinCastExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfExpectedTypeCastExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoOperatorExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfModuleUsingFragment::IVisitor)
				void Visit(vl::workflow::WfModuleUsingNameFragment* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfModuleUsingWildCardFragment* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfModuleUsingFragment::IVisitor)

#endif
			extern bool WfLoadTypes();
		}
	}
}
#endif